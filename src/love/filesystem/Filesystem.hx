// Generated by https://github.com/jurmerlo/love2d-hx.
// Love2D Version 11.5.

package love.filesystem;
import haxe.extern.Rest;
import love.Data;
import love.data.ContainerType;
import lua.Table;
import lua.UserData;

/**
 * Provides an interface to the user's filesystem.
 */
@:native('love.filesystem')
extern class Filesystem {

	/**
	 * Append data to an existing file.
	 * @param name The name (and path) of the file.
	 * @param data The string data to append to the file.
	 * @param size How many bytes to write.
	 */
	@:overload(function (name: String, data: Data, ?size: Float): FilesystemAppendResult {})
	public static function append(name: String, data: String, ?size: Float): FilesystemAppendResult;

	/**
	 * Gets whether love.filesystem follows symbolic links.
	 * @return Whether love.filesystem follows symbolic links.
	 */
	public static function areSymlinksEnabled(): Bool;

	/**
	 * Recursively creates a directory.
	 * When called with 'a/b' it creates both 'a' and 'a/b', if they don't exist already.
	 * @param name The directory to create.
	 * @return True if the directory was created, false if not.
	 */
	public static function createDirectory(name: String): Bool;

	/**
	 * Returns the application data directory (could be the same as getUserDirectory)
	 * @return The path of the application data directory
	 */
	public static function getAppdataDirectory(): String;

	/**
	 * Gets the filesystem paths that will be searched for c libraries when require is called.
	 * The paths string returned by this function is a sequence of path templates separated by semicolons. The argument passed to ''require'' will be inserted in place of any question mark ('?') character in each template (after the dot characters in the argument passed to ''require'' are replaced by directory separators.) Additionally, any occurrence of a double question mark ('??') will be replaced by the name passed to require and the default library extension for the platform.
	 * The paths are relative to the game's source and save directories, as well as any paths mounted with love.filesystem.mount.
	 * @return The paths that the ''require'' function will check for c libraries in love's filesystem.
	 */
	public static function getCRequirePath(): String;

	/**
	 * Returns a table with the names of files and subdirectories in the specified path. The table is not sorted in any way; the order is undefined.
	 * If the path passed to the function exists in the game and the save directory, it will list the files and directories from both places.
	 * @param dir The directory.
	 * @return A sequence with the names of all files and subdirectories as strings.
	 */
	@:overload(function (dir: String, callback: Void -> Void): Table<Dynamic, Dynamic> {})
	public static function getDirectoryItems(dir: String): Table<Dynamic, Dynamic>;

	/**
	 * Gets the write directory name for your game. 
	 * Note that this only returns the name of the folder to store your files in, not the full path.
	 * @return The identity that is used as write directory.
	 */
	public static function getIdentity(): String;

	/**
	 * Gets information about the specified file or directory.
	 * @param path The file or directory path to check.
	 * @param filtertype If supplied, this parameter causes getInfo to only return the info table if the item at the given path matches the specified file type.
	 * @return A table containing information about the specified path, or nil if nothing exists at the path. The table contains the following fields:
	 */
	@:overload(function (path: String, info: Table<Dynamic, Dynamic>): Table<Dynamic, Dynamic> {})
	@:overload(function (path: String, filtertype: FileType, info: Table<Dynamic, Dynamic>): Table<Dynamic, Dynamic> {})
	public static function getInfo(path: String, ?filtertype: FileType): Table<Dynamic, Dynamic>;

	/**
	 * Gets the platform-specific absolute path of the directory containing a filepath.
	 * This can be used to determine whether a file is inside the save directory or the game's source .love.
	 * @param filepath The filepath to get the directory of.
	 * @return The platform-specific full path of the directory containing the filepath.
	 */
	public static function getRealDirectory(filepath: String): String;

	/**
	 * Gets the filesystem paths that will be searched when require is called.
	 * The paths string returned by this function is a sequence of path templates separated by semicolons. The argument passed to ''require'' will be inserted in place of any question mark ('?') character in each template (after the dot characters in the argument passed to ''require'' are replaced by directory separators.)
	 * The paths are relative to the game's source and save directories, as well as any paths mounted with love.filesystem.mount.
	 * @return The paths that the ''require'' function will check in love's filesystem.
	 */
	public static function getRequirePath(): String;

	/**
	 * Gets the full path to the designated save directory.
	 * This can be useful if you want to use the standard io library (or something else) to
	 * read or write in the save directory.
	 * @return The absolute path to the save directory.
	 */
	public static function getSaveDirectory(): String;

	/**
	 * Returns the full path to the the .love file or directory. If the game is fused to the LÖVE executable, then the executable is returned.
	 * @return The full platform-dependent path of the .love file or directory.
	 */
	public static function getSource(): String;

	/**
	 * Returns the full path to the directory containing the .love file. If the game is fused to the LÖVE executable, then the directory containing the executable is returned.
	 * If love.filesystem.isFused is true, the path returned by this function can be passed to love.filesystem.mount, which will make the directory containing the main game (e.g. C:\Program Files\coolgame\) readable by love.filesystem.
	 * @return The full platform-dependent path of the directory containing the .love file.
	 */
	public static function getSourceBaseDirectory(): String;

	/**
	 * Returns the path of the user's directory
	 * @return The path of the user's directory
	 */
	public static function getUserDirectory(): String;

	/**
	 * Gets the current working directory.
	 * @return The current working directory.
	 */
	public static function getWorkingDirectory(): String;

	/**
	 * Initializes love.filesystem, will be called internally, so should not be used explicitly.
	 * @param appname The name of the application binary, typically love.
	 */
	public static function init(appname: String): Void;

	/**
	 * Gets whether the game is in fused mode or not.
	 * If a game is in fused mode, its save directory will be directly in the Appdata directory instead of Appdata/LOVE/. The game will also be able to load C Lua dynamic libraries which are located in the save directory.
	 * A game is in fused mode if the source .love has been fused to the executable (see Game Distribution), or if '--fused' has been given as a command-line argument when starting the game.
	 * @return True if the game is in fused mode, false otherwise.
	 */
	public static function isFused(): Bool;

	/**
	 * Iterate over the lines in a file.
	 * @param name The name (and path) of the file
	 * @return A function that iterates over all the lines in the file
	 */
	public static function lines(name: String): Void -> String;

	/**
	 * Loads a Lua file (but does not run it).
	 * @param name The name (and path) of the file.
	 */
	public static function load(name: String): FilesystemLoadResult;

	/**
	 * Mounts a zip file or folder in the game's save directory for reading.
	 * It is also possible to mount love.filesystem.getSourceBaseDirectory if the game is in fused mode.
	 * @param archive The folder or zip file in the game's save directory to mount.
	 * @param mountpoint The new path the archive will be mounted to.
	 * @param appendToPath Whether the archive will be searched when reading a filepath before or after already-mounted archives. This includes the game's source and save directories.
	 * @return True if the archive was successfully mounted, false otherwise.
	 */
	@:overload(function (filedata: FileData, mountpoint: String, ?appendToPath: Bool): Bool {})
	@:overload(function (data: Data, archivename: String, mountpoint: String, ?appendToPath: Bool): Bool {})
	public static function mount(archive: String, mountpoint: String, ?appendToPath: Bool): Bool;

	/**
	 * Creates a new File object. 
	 * It needs to be opened before it can be accessed.
	 * @param filename The filename of the file.
	 * @return The new File object.
	 */
	@:overload(function (filename: String, mode: FileMode): FilesystemNewFileResult {})
	public static function newFile(filename: String): File;

	/**
	 * Creates a new FileData object from a file on disk, or from a string in memory.
	 * @param contents The contents of the file in memory represented as a string.
	 * @param name The name of the file. The extension may be parsed and used by LÖVE when passing the FileData object into love.audio.newSource.
	 * @return The new FileData.
	 */
	@:overload(function (originaldata: Data, name: String): FileData {})
	@:overload(function (filepath: String): FilesystemNewFileDataResult {})
	public static function newFileData(contents: String, name: String): FileData;

	/**
	 * Read the contents of a file.
	 * @param name The name (and path) of the file.
	 * @param size How many bytes to read.
	 */
	@:overload(function (container: ContainerType, name: String, ?size: Float): FilesystemReadResult {})
	public static function read(name: String, ?size: Float): FilesystemReadResult;

	/**
	 * Removes a file or empty directory.
	 * @param name The file or directory to remove.
	 * @return True if the file/directory was removed, false otherwise.
	 */
	public static function remove(name: String): Bool;

	/**
	 * Sets the filesystem paths that will be searched for c libraries when require is called.
	 * The paths string returned by this function is a sequence of path templates separated by semicolons. The argument passed to ''require'' will be inserted in place of any question mark ('?') character in each template (after the dot characters in the argument passed to ''require'' are replaced by directory separators.) Additionally, any occurrence of a double question mark ('??') will be replaced by the name passed to require and the default library extension for the platform.
	 * The paths are relative to the game's source and save directories, as well as any paths mounted with love.filesystem.mount.
	 * @param paths The paths that the ''require'' function will check in love's filesystem.
	 */
	public static function setCRequirePath(paths: String): Void;

	/**
	 * Sets the write directory for your game. 
	 * Note that you can only set the name of the folder to store your files in, not the location.
	 * @param name The new identity that will be used as write directory.
	 */
	@:overload(function (name: String): Void {})
	public static function setIdentity(name: String): Void;

	/**
	 * Sets the filesystem paths that will be searched when require is called.
	 * The paths string given to this function is a sequence of path templates separated by semicolons. The argument passed to ''require'' will be inserted in place of any question mark ('?') character in each template (after the dot characters in the argument passed to ''require'' are replaced by directory separators.)
	 * The paths are relative to the game's source and save directories, as well as any paths mounted with love.filesystem.mount.
	 * @param paths The paths that the ''require'' function will check in love's filesystem.
	 */
	public static function setRequirePath(paths: String): Void;

	/**
	 * Sets the source of the game, where the code is present. This function can only be called once, and is normally automatically done by LÖVE.
	 * @param path Absolute path to the game's source folder.
	 */
	public static function setSource(path: String): Void;

	/**
	 * Sets whether love.filesystem follows symbolic links. It is enabled by default in version 0.10.0 and newer, and disabled by default in 0.9.2.
	 * @param enable Whether love.filesystem should follow symbolic links.
	 */
	public static function setSymlinksEnabled(enable: Bool): Void;

	/**
	 * Unmounts a zip file or folder previously mounted for reading with love.filesystem.mount.
	 * @param archive The folder or zip file in the game's save directory which is currently mounted.
	 * @return True if the archive was successfully unmounted, false otherwise.
	 */
	public static function unmount(archive: String): Bool;

	/**
	 * Write data to a file in the save directory. If the file existed already, it will be completely replaced by the new contents.
	 * @param name The name (and path) of the file.
	 * @param data The string data to write to the file.
	 * @param size How many bytes to write.
	 */
	@:overload(function (name: String, data: Data, ?size: Float): FilesystemWriteResult {})
	public static function write(name: String, data: String, ?size: Float): FilesystemWriteResult;
}

@:multiReturn
extern class FilesystemWriteResult {
	var success: Bool;
	var message: String;
}

@:multiReturn
extern class FilesystemReadResult {
	var contents: Dynamic;
	var size: Float;
	var error: String;
}

@:multiReturn
extern class FilesystemNewFileDataResult {
	var data: FileData;
	var err: String;
}

@:multiReturn
extern class FilesystemNewFileResult {
	var file: File;
	var errorstr: String;
}

@:multiReturn
extern class FilesystemLoadResult {
	var chunk: Void -> Void;
	var errormsg: String;
}

@:multiReturn
extern class FilesystemAppendResult {
	var success: Bool;
	var errormsg: String;
}