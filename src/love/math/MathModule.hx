// Generated by https://github.com/square-two/love2d-hx.
// Love2D Version 11.5.

package love.math;
import haxe.extern.Rest;
import lua.Table;
import lua.UserData;

/**
 * Provides system-independent mathematical functions.
 */
@:native('love.math')
extern class MathModule {

	/**
	 * Converts a color from 0..255 to 0..1 range.
	 * @param rb Red color component in 0..255 range.
	 * @param gb Green color component in 0..255 range.
	 * @param bb Blue color component in 0..255 range.
	 * @param ab Alpha color component in 0..255 range.
	 */
	public static function colorFromBytes(rb: Float, gb: Float, bb: Float, ?ab: Float): MathModuleColorFromBytesResult;

	/**
	 * Converts a color from 0..1 to 0..255 range.
	 * @param r Red color component.
	 * @param g Green color component.
	 * @param b Blue color component.
	 * @param a Alpha color component.
	 */
	public static function colorToBytes(r: Float, g: Float, b: Float, ?a: Float): MathModuleColorToBytesResult;

	/**
	 * Converts a color from gamma-space (sRGB) to linear-space (RGB). This is useful when doing gamma-correct rendering and you need to do math in linear RGB in the few cases where LÖVE doesn't handle conversions automatically.
	 * Read more about gamma-correct rendering here, here, and here.
	 * In versions prior to 11.0, color component values were within the range of 0 to 255 instead of 0 to 1.
	 * @param r The red channel of the sRGB color to convert.
	 * @param g The green channel of the sRGB color to convert.
	 * @param b The blue channel of the sRGB color to convert.
	 */
	@:overload(function (color: Table<Dynamic, Dynamic>): MathModuleGammaToLinearResult {})
	@:overload(function (c: Float): Float {})
	public static function gammaToLinear(r: Float, g: Float, b: Float): MathModuleGammaToLinearResult;

	/**
	 * Gets the seed of the random number generator.
	 * The seed is split into two numbers due to Lua's use of doubles for all number values - doubles can't accurately represent integer  values above 2^53, but the seed can be an integer value up to 2^64.
	 */
	public static function getRandomSeed(): MathModuleGetRandomSeedResult;

	/**
	 * Gets the current state of the random number generator. This returns an opaque implementation-dependent string which is only useful for later use with love.math.setRandomState or RandomGenerator:setState.
	 * This is different from love.math.getRandomSeed in that getRandomState gets the random number generator's current state, whereas getRandomSeed gets the previously set seed number.
	 * @return The current state of the random number generator, represented as a string.
	 */
	public static function getRandomState(): String;

	/**
	 * Checks whether a polygon is convex.
	 * PolygonShapes in love.physics, some forms of Meshes, and polygons drawn with love.graphics.polygon must be simple convex polygons.
	 * @param vertices The vertices of the polygon as a table in the form of {x1, y1, x2, y2, x3, y3, ...}.
	 * @return Whether the given polygon is convex.
	 */
	@:overload(function (x1: Float, y1: Float, x2: Float, y2: Float, args: Rest<Float>): Bool {})
	public static function isConvex(vertices: Table<Dynamic, Dynamic>): Bool;

	/**
	 * Converts a color from linear-space (RGB) to gamma-space (sRGB). This is useful when storing linear RGB color values in an image, because the linear RGB color space has less precision than sRGB for dark colors, which can result in noticeable color banding when drawing.
	 * In general, colors chosen based on what they look like on-screen are already in gamma-space and should not be double-converted. Colors calculated using math are often in the linear RGB space.
	 * Read more about gamma-correct rendering here, here, and here.
	 * In versions prior to 11.0, color component values were within the range of 0 to 255 instead of 0 to 1.
	 * @param lr The red channel of the linear RGB color to convert.
	 * @param lg The green channel of the linear RGB color to convert.
	 * @param lb The blue channel of the linear RGB color to convert.
	 */
	@:overload(function (color: Table<Dynamic, Dynamic>): MathModuleLinearToGammaResult {})
	@:overload(function (lc: Float): Float {})
	public static function linearToGamma(lr: Float, lg: Float, lb: Float): MathModuleLinearToGammaResult;

	/**
	 * Creates a new BezierCurve object.
	 * The number of vertices in the control polygon determines the degree of the curve, e.g. three vertices define a quadratic (degree 2) Bézier curve, four vertices define a cubic (degree 3) Bézier curve, etc.
	 * @param vertices The vertices of the control polygon as a table in the form of {x1, y1, x2, y2, x3, y3, ...}.
	 * @return A Bézier curve object.
	 */
	@:overload(function (x1: Float, y1: Float, x2: Float, y2: Float, args: Rest<Float>): BezierCurve {})
	public static function newBezierCurve(vertices: Table<Dynamic, Dynamic>): BezierCurve;

	/**
	 * Creates a new RandomGenerator object which is completely independent of other RandomGenerator objects and random functions.
	 * @return The new Random Number Generator object.
	 */
	@:overload(function (seed: Float): RandomGenerator {})
	@:overload(function (low: Float, high: Float): RandomGenerator {})
	public static function newRandomGenerator(): RandomGenerator;

	/**
	 * Creates a new Transform object.
	 * @return The new Transform object.
	 */
	@:overload(function (x: Float, y: Float, ?angle: Float, ?sx: Float, ?sy: Float, ?ox: Float, ?oy: Float, ?kx: Float, ?ky: Float): Transform {})
	public static function newTransform(): Transform;

	/**
	 * Generates a Simplex or Perlin noise value in 1-4 dimensions. The return value will always be the same, given the same arguments.
	 * Simplex noise is closely related to Perlin noise. It is widely used for procedural content generation.
	 * There are many webpages which discuss Perlin and Simplex noise in detail.
	 * @param x The number used to generate the noise value.
	 * @return The noise value in the range of 1.
	 */
	@:overload(function (x: Float, y: Float): Float {})
	@:overload(function (x: Float, y: Float, z: Float): Float {})
	@:overload(function (x: Float, y: Float, z: Float, w: Float): Float {})
	public static function noise(x: Float): Float;

	/**
	 * Generates a pseudo-random number in a platform independent manner. The default love.run seeds this function at startup, so you generally don't need to seed it yourself.
	 * @return The pseudo-random number.
	 */
	@:overload(function (max: Float): Float {})
	@:overload(function (min: Float, max: Float): Float {})
	public static function random(): Float;

	/**
	 * Get a normally distributed pseudo random number.
	 * @param stddev Standard deviation of the distribution.
	 * @param mean The mean of the distribution.
	 * @return Normally distributed random number with variance (stddev)² and the specified mean.
	 */
	public static function randomNormal(?stddev: Float, ?mean: Float): Float;

	/**
	 * Sets the seed of the random number generator using the specified integer number. This is called internally at startup, so you generally don't need to call it yourself.
	 * @param seed The integer number with which you want to seed the randomization. Must be within the range of 2^53 - 1.
	 */
	@:overload(function (low: Float, high: Float): Void {})
	public static function setRandomSeed(seed: Float): Void;

	/**
	 * Sets the current state of the random number generator. The value used as an argument for this function is an opaque implementation-dependent string and should only originate from a previous call to love.math.getRandomState.
	 * This is different from love.math.setRandomSeed in that setRandomState directly sets the random number generator's current implementation-dependent state, whereas setRandomSeed gives it a new seed value.
	 * @param state The new state of the random number generator, represented as a string. This should originate from a previous call to love.math.getRandomState.
	 */
	public static function setRandomState(state: String): Void;

	/**
	 * Decomposes a simple convex or concave polygon into triangles.
	 * @param polygon Polygon to triangulate. Must not intersect itself.
	 * @return List of triangles the polygon is composed of, in the form of {{x1, y1, x2, y2, x3, y3},  {x1, y1, x2, y2, x3, y3}, ...}.
	 */
	@:overload(function (x1: Float, y1: Float, x2: Float, y2: Float, x3: Float, y3: Float): Table<Dynamic, Dynamic> {})
	public static function triangulate(polygon: Table<Dynamic, Dynamic>): Table<Dynamic, Dynamic>;
}

@:multiReturn
extern class MathModuleLinearToGammaResult {
	var cr: Float;
	var cg: Float;
	var cb: Float;
}

@:multiReturn
extern class MathModuleGetRandomSeedResult {
	var low: Float;
	var high: Float;
}

@:multiReturn
extern class MathModuleGammaToLinearResult {
	var lr: Float;
	var lg: Float;
	var lb: Float;
}

@:multiReturn
extern class MathModuleColorToBytesResult {
	var rb: Float;
	var gb: Float;
	var bb: Float;
	var ab: Float;
}

@:multiReturn
extern class MathModuleColorFromBytesResult {
	var r: Float;
	var g: Float;
	var b: Float;
	var a: Float;
}