// Generated by https://github.com/square-two/love2d-hx.
// Love2D Version 11.5.

package love.math;
import haxe.extern.Rest;
import lua.Table;
import lua.UserData;

/**
 * A Bézier curve object that can evaluate and render Bézier curves of arbitrary degree.
 * For more information on Bézier curves check this great article on Wikipedia.
 */
extern class BezierCurve extends Object {

	/**
	 * Evaluate Bézier curve at parameter t. The parameter must be between 0 and 1 (inclusive).
	 * This function can be used to move objects along paths or tween parameters. However it should not be used to render the curve, see BezierCurve:render for that purpose.
	 * @param t Where to evaluate the curve.
	 */
	public function evaluate(t: Float): BezierCurveEvaluateResult;

	/**
	 * Get coordinates of the i-th control point. Indices start with 1.
	 * @param i Index of the control point.
	 */
	public function getControlPoint(i: Float): BezierCurveGetControlPointResult;

	/**
	 * Get the number of control points in the Bézier curve.
	 * @return The number of control points.
	 */
	public function getControlPointCount(): Float;

	/**
	 * Get degree of the Bézier curve. The degree is equal to number-of-control-points - 1.
	 * @return Degree of the Bézier curve.
	 */
	public function getDegree(): Float;

	/**
	 * Get the derivative of the Bézier curve.
	 * This function can be used to rotate sprites moving along a curve in the direction of the movement and compute the direction perpendicular to the curve at some parameter t.
	 * @return The derivative curve.
	 */
	public function getDerivative(): BezierCurve;

	/**
	 * Gets a BezierCurve that corresponds to the specified segment of this BezierCurve.
	 * @param startpoint The starting point along the curve. Must be between 0 and 1.
	 * @param endpoint The end of the segment. Must be between 0 and 1.
	 * @return A BezierCurve that corresponds to the specified segment.
	 */
	public function getSegment(startpoint: Float, endpoint: Float): BezierCurve;

	/**
	 * Insert control point as the new i-th control point. Existing control points from i onwards are pushed back by 1. Indices start with 1. Negative indices wrap around: -1 is the last control point, -2 the one before the last, etc.
	 * @param x Position of the control point along the x axis.
	 * @param y Position of the control point along the y axis.
	 * @param i Index of the control point.
	 */
	public function insertControlPoint(x: Float, y: Float, ?i: Float): Void;

	/**
	 * Removes the specified control point.
	 * @param index The index of the control point to remove.
	 */
	public function removeControlPoint(index: Float): Void;

	/**
	 * Get a list of coordinates to be used with love.graphics.line.
	 * This function samples the Bézier curve using recursive subdivision. You can control the recursion depth using the depth parameter.
	 * If you are just interested to know the position on the curve given a parameter, use BezierCurve:evaluate.
	 * @param depth Number of recursive subdivision steps.
	 * @return List of x,y-coordinate pairs of points on the curve.
	 */
	public function render(?depth: Float): Table<Dynamic, Dynamic>;

	/**
	 * Get a list of coordinates on a specific part of the curve, to be used with love.graphics.line.
	 * This function samples the Bézier curve using recursive subdivision. You can control the recursion depth using the depth parameter.
	 * If you are just need to know the position on the curve given a parameter, use BezierCurve:evaluate.
	 * @param startpoint The starting point along the curve. Must be between 0 and 1.
	 * @param endpoint The end of the segment to render. Must be between 0 and 1.
	 * @param depth Number of recursive subdivision steps.
	 * @return List of x,y-coordinate pairs of points on the specified part of the curve.
	 */
	public function renderSegment(startpoint: Float, endpoint: Float, ?depth: Float): Table<Dynamic, Dynamic>;

	/**
	 * Rotate the Bézier curve by an angle.
	 * @param angle Rotation angle in radians.
	 * @param ox X coordinate of the rotation center.
	 * @param oy Y coordinate of the rotation center.
	 */
	public function rotate(angle: Float, ?ox: Float, ?oy: Float): Void;

	/**
	 * Scale the Bézier curve by a factor.
	 * @param s Scale factor.
	 * @param ox X coordinate of the scaling center.
	 * @param oy Y coordinate of the scaling center.
	 */
	public function scale(s: Float, ?ox: Float, ?oy: Float): Void;

	/**
	 * Set coordinates of the i-th control point. Indices start with 1.
	 * @param i Index of the control point.
	 * @param x Position of the control point along the x axis.
	 * @param y Position of the control point along the y axis.
	 */
	public function setControlPoint(i: Float, x: Float, y: Float): Void;

	/**
	 * Move the Bézier curve by an offset.
	 * @param dx Offset along the x axis.
	 * @param dy Offset along the y axis.
	 */
	public function translate(dx: Float, dy: Float): Void;
}