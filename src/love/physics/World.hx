// Generated by https://github.com/square-two/love2d-hx.
// Love2D Version 11.5.

package love.physics;
import haxe.extern.Rest;
import lua.Table;
import lua.UserData;

/**
 * A world is an object that contains all bodies and joints.
 */
extern class World extends Object {

	/**
	 * Destroys the world, taking all bodies, joints, fixtures and their shapes with it. 
	 * An error will occur if you attempt to use any of the destroyed objects after calling this function.
	 */
	public function destroy(): Void;

	/**
	 * Returns a table with all bodies.
	 * @return A sequence with all bodies.
	 */
	public function getBodies(): Table<Dynamic, Dynamic>;

	/**
	 * Returns the number of bodies in the world.
	 * @return The number of bodies in the world.
	 */
	public function getBodyCount(): Float;

	/**
	 * Returns functions for the callbacks during the world update.
	 */
	public function getCallbacks(): WorldGetCallbacksResult;

	/**
	 * Returns the number of contacts in the world.
	 * @return The number of contacts in the world.
	 */
	public function getContactCount(): Float;

	/**
	 * Returns the function for collision filtering.
	 * @return The function that handles the contact filtering.
	 */
	public function getContactFilter(): Void -> Void;

	/**
	 * Returns a table with all Contacts.
	 * @return A sequence with all Contacts.
	 */
	public function getContacts(): Table<Dynamic, Dynamic>;

	/**
	 * Get the gravity of the world.
	 */
	public function getGravity(): WorldGetGravityResult;

	/**
	 * Returns the number of joints in the world.
	 * @return The number of joints in the world.
	 */
	public function getJointCount(): Float;

	/**
	 * Returns a table with all joints.
	 * @return A sequence with all joints.
	 */
	public function getJoints(): Table<Dynamic, Dynamic>;

	/**
	 * Gets whether the World is destroyed. Destroyed worlds cannot be used.
	 * @return Whether the World is destroyed.
	 */
	public function isDestroyed(): Bool;

	/**
	 * Returns if the world is updating its state.
	 * This will return true inside the callbacks from World:setCallbacks.
	 * @return Will be true if the world is in the process of updating its state.
	 */
	public function isLocked(): Bool;

	/**
	 * Gets the sleep behaviour of the world.
	 * @return True if bodies in the world are allowed to sleep, or false if not.
	 */
	public function isSleepingAllowed(): Bool;

	/**
	 * Calls a function for each fixture inside the specified area by searching for any overlapping bounding box (Fixture:getBoundingBox).
	 * @param topLeftX The x position of the top-left point.
	 * @param topLeftY The y position of the top-left point.
	 * @param bottomRightX The x position of the bottom-right point.
	 * @param bottomRightY The y position of the bottom-right point.
	 * @param callback This function gets passed one argument, the fixture, and should return a boolean. The search will continue if it is true or stop if it is false.
	 */
	public function queryBoundingBox(topLeftX: Float, topLeftY: Float, bottomRightX: Float, bottomRightY: Float, callback: Void -> Void): Void;

	/**
	 * Casts a ray and calls a function for each fixtures it intersects. 
	 * @param x1 The x position of the starting point of the ray.
	 * @param y1 The x position of the starting point of the ray.
	 * @param x2 The x position of the end point of the ray.
	 * @param y2 The x value of the surface normal vector of the shape edge.
	 * @param callback A function called for each fixture intersected by the ray. The function gets six arguments and should return a number as a control value. The intersection points fed into the function will be in an arbitrary order. If you wish to find the closest point of intersection, you'll need to do that yourself within the function. The easiest way to do that is by using the fraction value.
	 */
	public function rayCast(x1: Float, y1: Float, x2: Float, y2: Float, callback: Void -> Void): Void;

	/**
	 * Sets functions for the collision callbacks during the world update.
	 * Four Lua functions can be given as arguments. The value nil removes a function.
	 * When called, each function will be passed three arguments. The first two arguments are the colliding fixtures and the third argument is the Contact between them. The postSolve callback additionally gets the normal and tangent impulse for each contact point. See notes.
	 * If you are interested to know when exactly each callback is called, consult a Box2d manual
	 * @param beginContact Gets called when two fixtures begin to overlap.
	 * @param endContact Gets called when two fixtures cease to overlap. This will also be called outside of a world update, when colliding objects are destroyed.
	 * @param preSolve Gets called before a collision gets resolved.
	 * @param postSolve Gets called after the collision has been resolved.
	 */
	public function setCallbacks(beginContact: Void -> Void, endContact: Void -> Void, ?preSolve: Void -> Void, ?postSolve: Void -> Void): Void;

	/**
	 * Sets a function for collision filtering.
	 * If the group and category filtering doesn't generate a collision decision, this function gets called with the two fixtures as arguments. The function should return a boolean value where true means the fixtures will collide and false means they will pass through each other.
	 * @param filter The function handling the contact filtering.
	 */
	public function setContactFilter(filter: Void -> Void): Void;

	/**
	 * Set the gravity of the world.
	 * @param x The x component of gravity.
	 * @param y The y component of gravity.
	 */
	public function setGravity(x: Float, y: Float): Void;

	/**
	 * Sets the sleep behaviour of the world.
	 * @param allow True if bodies in the world are allowed to sleep, or false if not.
	 */
	public function setSleepingAllowed(allow: Bool): Void;

	/**
	 * Translates the World's origin. Useful in large worlds where floating point precision issues become noticeable at far distances from the origin.
	 * @param x The x component of the new origin with respect to the old origin.
	 * @param y The y component of the new origin with respect to the old origin.
	 */
	public function translateOrigin(x: Float, y: Float): Void;

	/**
	 * Update the state of the world.
	 * @param dt The time (in seconds) to advance the physics simulation.
	 * @param velocityiterations The maximum number of steps used to determine the new velocities when resolving a collision.
	 * @param positioniterations The maximum number of steps used to determine the new positions when resolving a collision.
	 */
	public function update(dt: Float, ?velocityiterations: Float, ?positioniterations: Float): Void;
}

@:multiReturn
extern class WorldGetGravityResult {
	var x: Float;
	var y: Float;
}

@:multiReturn
extern class WorldGetCallbacksResult {
	var beginContact: Void -> Void;
	var endContact: Void -> Void;
	var preSolve: Void -> Void;
	var postSolve: Void -> Void;
}