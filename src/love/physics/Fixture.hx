// Generated by https://github.com/square-two/love2d-hx.
// Love2D Version 11.5.

package love.physics;
import haxe.extern.Rest;
import lua.Table;
import lua.UserData;

/**
 * Fixtures attach shapes to bodies.
 */
extern class Fixture extends Object {

	/**
	 * Destroys the fixture.
	 */
	public function destroy(): Void;

	/**
	 * Returns the body to which the fixture is attached.
	 * @return The parent body.
	 */
	public function getBody(): Body;

	/**
	 * Returns the points of the fixture bounding box. In case the fixture has multiple children a 1-based index can be specified. For example, a fixture will have multiple children with a chain shape.
	 * @param index A bounding box of the fixture.
	 */
	public function getBoundingBox(?index: Float): FixtureGetBoundingBoxResult;

	/**
	 * Returns the categories the fixture belongs to.
	 * @return The categories.
	 */
	public function getCategory(): Float;

	/**
	 * Returns the density of the fixture.
	 * @return The fixture density in kilograms per square meter.
	 */
	public function getDensity(): Float;

	/**
	 * Returns the filter data of the fixture.
	 * Categories and masks are encoded as the bits of a 16-bit integer.
	 */
	public function getFilterData(): FixtureGetFilterDataResult;

	/**
	 * Returns the friction of the fixture.
	 * @return The fixture friction.
	 */
	public function getFriction(): Float;

	/**
	 * Returns the group the fixture belongs to. Fixtures with the same group will always collide if the group is positive or never collide if it's negative. The group zero means no group.
	 * The groups range from -32768 to 32767.
	 * @return The group of the fixture.
	 */
	public function getGroupIndex(): Float;

	/**
	 * Returns which categories this fixture should '''NOT''' collide with.
	 * @return The masks.
	 */
	public function getMask(): Float;

	/**
	 * Returns the mass, its center and the rotational inertia.
	 */
	public function getMassData(): FixtureGetMassDataResult;

	/**
	 * Returns the restitution of the fixture.
	 * @return The fixture restitution.
	 */
	public function getRestitution(): Float;

	/**
	 * Returns the shape of the fixture. This shape is a reference to the actual data used in the simulation. It's possible to change its values between timesteps.
	 * @return The fixture's shape.
	 */
	public function getShape(): Shape;

	/**
	 * Returns the Lua value associated with this fixture.
	 * @return The Lua value associated with the fixture.
	 */
	public function getUserData(): Dynamic;

	/**
	 * Gets whether the Fixture is destroyed. Destroyed fixtures cannot be used.
	 * @return Whether the Fixture is destroyed.
	 */
	public function isDestroyed(): Bool;

	/**
	 * Returns whether the fixture is a sensor.
	 * @return If the fixture is a sensor.
	 */
	public function isSensor(): Bool;

	/**
	 * Casts a ray against the shape of the fixture and returns the surface normal vector and the line position where the ray hit. If the ray missed the shape, nil will be returned.
	 * The ray starts on the first point of the input line and goes towards the second point of the line. The fifth argument is the maximum distance the ray is going to travel as a scale factor of the input line length.
	 * The childIndex parameter is used to specify which child of a parent shape, such as a ChainShape, will be ray casted. For ChainShapes, the index of 1 is the first edge on the chain. Ray casting a parent shape will only test the child specified so if you want to test every shape of the parent, you must loop through all of its children.
	 * The world position of the impact can be calculated by multiplying the line vector with the third return value and adding it to the line starting point.
	 * hitx, hity = x1 + (x2 - x1) * fraction, y1 + (y2 - y1) * fraction
	 * @param x1 The x position of the input line starting point.
	 * @param y1 The y position of the input line starting point.
	 * @param x2 The x position of the input line end point.
	 * @param y2 The y position of the input line end point.
	 * @param maxFraction Ray length parameter.
	 * @param childIndex The index of the child the ray gets cast against.
	 */
	public function rayCast(x1: Float, y1: Float, x2: Float, y2: Float, maxFraction: Float, ?childIndex: Float): FixtureRayCastResult;

	/**
	 * Sets the categories the fixture belongs to. There can be up to 16 categories represented as a number from 1 to 16.
	 * All fixture's default category is 1.
	 * @param ... The categories.
	 */
	public function setCategory(args: Rest<Float>): Void;

	/**
	 * Sets the density of the fixture. Call Body:resetMassData if this needs to take effect immediately.
	 * @param density The fixture density in kilograms per square meter.
	 */
	public function setDensity(density: Float): Void;

	/**
	 * Sets the filter data of the fixture.
	 * Groups, categories, and mask can be used to define the collision behaviour of the fixture.
	 * If two fixtures are in the same group they either always collide if the group is positive, or never collide if it's negative. If the group is zero or they do not match, then the contact filter checks if the fixtures select a category of the other fixture with their masks. The fixtures do not collide if that's not the case. If they do have each other's categories selected, the return value of the custom contact filter will be used. They always collide if none was set.
	 * There can be up to 16 categories. Categories and masks are encoded as the bits of a 16-bit integer.
	 * When created, prior to calling this function, all fixtures have category set to 1, mask set to 65535 (all categories) and group set to 0.
	 * This function allows setting all filter data for a fixture at once. To set only the categories, the mask or the group, you can use Fixture:setCategory, Fixture:setMask or Fixture:setGroupIndex respectively.
	 * @param categories The categories as an integer from 0 to 65535.
	 * @param mask The mask as an integer from 0 to 65535.
	 * @param group The group as an integer from -32768 to 32767.
	 */
	public function setFilterData(categories: Float, mask: Float, group: Float): Void;

	/**
	 * Sets the friction of the fixture.
	 * Friction determines how shapes react when they 'slide' along other shapes. Low friction indicates a slippery surface, like ice, while high friction indicates a rough surface, like concrete. Range: 0.0 - 1.0.
	 * @param friction The fixture friction.
	 */
	public function setFriction(friction: Float): Void;

	/**
	 * Sets the group the fixture belongs to. Fixtures with the same group will always collide if the group is positive or never collide if it's negative. The group zero means no group.
	 * The groups range from -32768 to 32767.
	 * @param group The group as an integer from -32768 to 32767.
	 */
	public function setGroupIndex(group: Float): Void;

	/**
	 * Sets the category mask of the fixture. There can be up to 16 categories represented as a number from 1 to 16.
	 * This fixture will '''NOT''' collide with the fixtures that are in the selected categories if the other fixture also has a category of this fixture selected.
	 * @param ... The masks.
	 */
	public function setMask(args: Rest<Float>): Void;

	/**
	 * Sets the restitution of the fixture.
	 * @param restitution The fixture restitution.
	 */
	public function setRestitution(restitution: Float): Void;

	/**
	 * Sets whether the fixture should act as a sensor.
	 * Sensors do not cause collision responses, but the begin-contact and end-contact World callbacks will still be called for this fixture.
	 * @param sensor The sensor status.
	 */
	public function setSensor(sensor: Bool): Void;

	/**
	 * Associates a Lua value with the fixture.
	 * To delete the reference, explicitly pass nil.
	 * @param value The Lua value to associate with the fixture.
	 */
	public function setUserData(value: Dynamic): Void;

	/**
	 * Checks if a point is inside the shape of the fixture.
	 * @param x The x position of the point.
	 * @param y The y position of the point.
	 * @return True if the point is inside or false if it is outside.
	 */
	public function testPoint(x: Float, y: Float): Bool;
}

@:multiReturn
extern class FixtureRayCastResult {
	var xn: Float;
	var yn: Float;
	var fraction: Float;
}

@:multiReturn
extern class FixtureGetMassDataResult {
	var x: Float;
	var y: Float;
	var mass: Float;
	var inertia: Float;
}

@:multiReturn
extern class FixtureGetFilterDataResult {
	var categories: Float;
	var mask: Float;
	var group: Float;
}

@:multiReturn
extern class FixtureGetBoundingBoxResult {
	var topLeftX: Float;
	var topLeftY: Float;
	var bottomRightX: Float;
	var bottomRightY: Float;
}