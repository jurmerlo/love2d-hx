// Generated by https://github.com/square-two/love2d-hx.
// Love2D Version 11.5.

package love.physics;
import haxe.extern.Rest;
import lua.Table;
import lua.UserData;

/**
 * Bodies are objects with velocity and position.
 */
extern class Body extends Object {

	/**
	 * Applies an angular impulse to a body. This makes a single, instantaneous addition to the body momentum.
	 * A body with with a larger mass will react less. The reaction does '''not''' depend on the timestep, and is equivalent to applying a force continuously for 1 second. Impulses are best used to give a single push to a body. For a continuous push to a body it is better to use Body:applyForce.
	 * @param impulse The impulse in kilogram-square meter per second.
	 */
	public function applyAngularImpulse(impulse: Float): Void;

	/**
	 * Apply force to a Body.
	 * A force pushes a body in a direction. A body with with a larger mass will react less. The reaction also depends on how long a force is applied: since the force acts continuously over the entire timestep, a short timestep will only push the body for a short time. Thus forces are best used for many timesteps to give a continuous push to a body (like gravity). For a single push that is independent of timestep, it is better to use Body:applyLinearImpulse.
	 * If the position to apply the force is not given, it will act on the center of mass of the body. The part of the force not directed towards the center of mass will cause the body to spin (and depends on the rotational inertia).
	 * Note that the force components and position must be given in world coordinates.
	 * @param fx The x component of force to apply to the center of mass.
	 * @param fy The y component of force to apply to the center of mass.
	 */
	@:overload(function (fx: Float, fy: Float, x: Float, y: Float): Void {})
	public function applyForce(fx: Float, fy: Float): Void;

	/**
	 * Applies an impulse to a body.
	 * This makes a single, instantaneous addition to the body momentum.
	 * An impulse pushes a body in a direction. A body with with a larger mass will react less. The reaction does '''not''' depend on the timestep, and is equivalent to applying a force continuously for 1 second. Impulses are best used to give a single push to a body. For a continuous push to a body it is better to use Body:applyForce.
	 * If the position to apply the impulse is not given, it will act on the center of mass of the body. The part of the impulse not directed towards the center of mass will cause the body to spin (and depends on the rotational inertia). 
	 * Note that the impulse components and position must be given in world coordinates.
	 * @param ix The x component of the impulse applied to the center of mass.
	 * @param iy The y component of the impulse applied to the center of mass.
	 */
	@:overload(function (ix: Float, iy: Float, x: Float, y: Float): Void {})
	public function applyLinearImpulse(ix: Float, iy: Float): Void;

	/**
	 * Apply torque to a body.
	 * Torque is like a force that will change the angular velocity (spin) of a body. The effect will depend on the rotational inertia a body has.
	 * @param torque The torque to apply.
	 */
	public function applyTorque(torque: Float): Void;

	/**
	 * Explicitly destroys the Body and all fixtures and joints attached to it.
	 * An error will occur if you attempt to use the object after calling this function. In 0.7.2, when you don't have time to wait for garbage collection, this function may be used to free the object immediately.
	 */
	public function destroy(): Void;

	/**
	 * Get the angle of the body.
	 * The angle is measured in radians. If you need to transform it to degrees, use math.deg.
	 * A value of 0 radians will mean 'looking to the right'. Although radians increase counter-clockwise, the y axis points down so it becomes ''clockwise'' from our point of view.
	 * @return The angle in radians.
	 */
	public function getAngle(): Float;

	/**
	 * Gets the Angular damping of the Body
	 * The angular damping is the ''rate of decrease of the angular velocity over time'': A spinning body with no damping and no external forces will continue spinning indefinitely. A spinning body with damping will gradually stop spinning.
	 * Damping is not the same as friction - they can be modelled together. However, only damping is provided by Box2D (and LOVE).
	 * Damping parameters should be between 0 and infinity, with 0 meaning no damping, and infinity meaning full damping. Normally you will use a damping value between 0 and 0.1.
	 * @return The value of the angular damping.
	 */
	public function getAngularDamping(): Float;

	/**
	 * Get the angular velocity of the Body.
	 * The angular velocity is the ''rate of change of angle over time''.
	 * It is changed in World:update by applying torques, off centre forces/impulses, and angular damping. It can be set directly with Body:setAngularVelocity.
	 * If you need the ''rate of change of position over time'', use Body:getLinearVelocity.
	 * @return The angular velocity in radians/second.
	 */
	public function getAngularVelocity(): Float;

	/**
	 * Gets a list of all Contacts attached to the Body.
	 * @return A list with all contacts associated with the Body.
	 */
	public function getContacts(): Table<Dynamic, Dynamic>;

	/**
	 * Returns a table with all fixtures.
	 * @return A sequence with all fixtures.
	 */
	public function getFixtures(): Table<Dynamic, Dynamic>;

	/**
	 * Returns the gravity scale factor.
	 * @return The gravity scale factor.
	 */
	public function getGravityScale(): Float;

	/**
	 * Gets the rotational inertia of the body.
	 * The rotational inertia is how hard is it to make the body spin.
	 * @return The rotational inertial of the body.
	 */
	public function getInertia(): Float;

	/**
	 * Returns a table containing the Joints attached to this Body.
	 * @return A sequence with the Joints attached to the Body.
	 */
	public function getJoints(): Table<Dynamic, Dynamic>;

	/**
	 * Gets the linear damping of the Body.
	 * The linear damping is the ''rate of decrease of the linear velocity over time''. A moving body with no damping and no external forces will continue moving indefinitely, as is the case in space. A moving body with damping will gradually stop moving.
	 * Damping is not the same as friction - they can be modelled together.
	 * @return The value of the linear damping.
	 */
	public function getLinearDamping(): Float;

	/**
	 * Gets the linear velocity of the Body from its center of mass.
	 * The linear velocity is the ''rate of change of position over time''.
	 * If you need the ''rate of change of angle over time'', use Body:getAngularVelocity.
	 * If you need to get the linear velocity of a point different from the center of mass:
	 * *  Body:getLinearVelocityFromLocalPoint allows you to specify the point in local coordinates.
	 * *  Body:getLinearVelocityFromWorldPoint allows you to specify the point in world coordinates.
	 * See page 136 of 'Essential Mathematics for Games and Interactive Applications' for definitions of local and world coordinates.
	 */
	public function getLinearVelocity(): BodyGetLinearVelocityResult;

	/**
	 * Get the linear velocity of a point on the body.
	 * The linear velocity for a point on the body is the velocity of the body center of mass plus the velocity at that point from the body spinning.
	 * The point on the body must given in local coordinates. Use Body:getLinearVelocityFromWorldPoint to specify this with world coordinates.
	 * @param x The x position to measure velocity.
	 * @param y The y position to measure velocity.
	 */
	public function getLinearVelocityFromLocalPoint(x: Float, y: Float): BodyGetLinearVelocityFromLocalPointResult;

	/**
	 * Get the linear velocity of a point on the body.
	 * The linear velocity for a point on the body is the velocity of the body center of mass plus the velocity at that point from the body spinning.
	 * The point on the body must given in world coordinates. Use Body:getLinearVelocityFromLocalPoint to specify this with local coordinates.
	 * @param x The x position to measure velocity.
	 * @param y The y position to measure velocity.
	 */
	public function getLinearVelocityFromWorldPoint(x: Float, y: Float): BodyGetLinearVelocityFromWorldPointResult;

	/**
	 * Get the center of mass position in local coordinates.
	 * Use Body:getWorldCenter to get the center of mass in world coordinates.
	 */
	public function getLocalCenter(): BodyGetLocalCenterResult;

	/**
	 * Transform a point from world coordinates to local coordinates.
	 * @param worldX The x position in world coordinates.
	 * @param worldY The y position in world coordinates.
	 */
	public function getLocalPoint(worldX: Float, worldY: Float): BodyGetLocalPointResult;

	/**
	 * Transforms multiple points from world coordinates to local coordinates.
	 * @param x1 (Argument) The x position of the first point.
	 * @param y1 (Argument) The y position of the first point.
	 * @param x2 (Argument) The x position of the second point.
	 * @param y2 (Argument) The y position of the second point.
	 * @param ... (Argument) You can continue passing x and y position of the points.
	 */
	public function getLocalPoints(x1: Float, y1: Float, x2: Float, y2: Float, args: Rest<Float>): BodyGetLocalPointsResult;

	/**
	 * Transform a vector from world coordinates to local coordinates.
	 * @param worldX The vector x component in world coordinates.
	 * @param worldY The vector y component in world coordinates.
	 */
	public function getLocalVector(worldX: Float, worldY: Float): BodyGetLocalVectorResult;

	/**
	 * Get the mass of the body.
	 * Static bodies always have a mass of 0.
	 * @return The mass of the body (in kilograms).
	 */
	public function getMass(): Float;

	/**
	 * Returns the mass, its center, and the rotational inertia.
	 */
	public function getMassData(): BodyGetMassDataResult;

	/**
	 * Get the position of the body.
	 * Note that this may not be the center of mass of the body.
	 */
	public function getPosition(): BodyGetPositionResult;

	/**
	 * Get the position and angle of the body.
	 * Note that the position may not be the center of mass of the body. An angle of 0 radians will mean 'looking to the right'. Although radians increase counter-clockwise, the y axis points down so it becomes clockwise from our point of view.
	 */
	public function getTransform(): BodyGetTransformResult;

	/**
	 * Returns the type of the body.
	 * @return The body type.
	 */
	public function getType(): BodyType;

	/**
	 * Returns the Lua value associated with this Body.
	 * @return The Lua value associated with the Body.
	 */
	public function getUserData(): Dynamic;

	/**
	 * Gets the World the body lives in.
	 * @return The world the body lives in.
	 */
	public function getWorld(): World;

	/**
	 * Get the center of mass position in world coordinates.
	 * Use Body:getLocalCenter to get the center of mass in local coordinates.
	 */
	public function getWorldCenter(): BodyGetWorldCenterResult;

	/**
	 * Transform a point from local coordinates to world coordinates.
	 * @param localX The x position in local coordinates.
	 * @param localY The y position in local coordinates.
	 */
	public function getWorldPoint(localX: Float, localY: Float): BodyGetWorldPointResult;

	/**
	 * Transforms multiple points from local coordinates to world coordinates.
	 * @param x1 The x position of the first point.
	 * @param y1 The y position of the first point.
	 * @param x2 The x position of the second point.
	 * @param y2 The y position of the second point.
	 */
	public function getWorldPoints(x1: Float, y1: Float, x2: Float, y2: Float): BodyGetWorldPointsResult;

	/**
	 * Transform a vector from local coordinates to world coordinates.
	 * @param localX The vector x component in local coordinates.
	 * @param localY The vector y component in local coordinates.
	 */
	public function getWorldVector(localX: Float, localY: Float): BodyGetWorldVectorResult;

	/**
	 * Get the x position of the body in world coordinates.
	 * @return The x position in world coordinates.
	 */
	public function getX(): Float;

	/**
	 * Get the y position of the body in world coordinates.
	 * @return The y position in world coordinates.
	 */
	public function getY(): Float;

	/**
	 * Returns whether the body is actively used in the simulation.
	 * @return True if the body is active or false if not.
	 */
	public function isActive(): Bool;

	/**
	 * Returns the sleep status of the body.
	 * @return True if the body is awake or false if not.
	 */
	public function isAwake(): Bool;

	/**
	 * Get the bullet status of a body.
	 * There are two methods to check for body collisions:
	 * *  at their location when the world is updated (default)
	 * *  using continuous collision detection (CCD)
	 * The default method is efficient, but a body moving very quickly may sometimes jump over another body without producing a collision. A body that is set as a bullet will use CCD. This is less efficient, but is guaranteed not to jump when moving quickly.
	 * Note that static bodies (with zero mass) always use CCD, so your walls will not let a fast moving body pass through even if it is not a bullet.
	 * @return The bullet status of the body.
	 */
	public function isBullet(): Bool;

	/**
	 * Gets whether the Body is destroyed. Destroyed bodies cannot be used.
	 * @return Whether the Body is destroyed.
	 */
	public function isDestroyed(): Bool;

	/**
	 * Returns whether the body rotation is locked.
	 * @return True if the body's rotation is locked or false if not.
	 */
	public function isFixedRotation(): Bool;

	/**
	 * Returns the sleeping behaviour of the body.
	 * @return True if the body is allowed to sleep or false if not.
	 */
	public function isSleepingAllowed(): Bool;

	/**
	 * Gets whether the Body is touching the given other Body.
	 * @param otherbody The other body to check.
	 * @return True if this body is touching the other body, false otherwise.
	 */
	public function isTouching(otherbody: Body): Bool;

	/**
	 * Resets the mass of the body by recalculating it from the mass properties of the fixtures.
	 */
	public function resetMassData(): Void;

	/**
	 * Sets whether the body is active in the world.
	 * An inactive body does not take part in the simulation. It will not move or cause any collisions.
	 * @param active If the body is active or not.
	 */
	public function setActive(active: Bool): Void;

	/**
	 * Set the angle of the body.
	 * The angle is measured in radians. If you need to transform it from degrees, use math.rad.
	 * A value of 0 radians will mean 'looking to the right'. Although radians increase counter-clockwise, the y axis points down so it becomes ''clockwise'' from our point of view.
	 * It is possible to cause a collision with another body by changing its angle. 
	 * @param angle The angle in radians.
	 */
	public function setAngle(angle: Float): Void;

	/**
	 * Sets the angular damping of a Body
	 * See Body:getAngularDamping for a definition of angular damping.
	 * Angular damping can take any value from 0 to infinity. It is recommended to stay between 0 and 0.1, though. Other values will look unrealistic.
	 * @param damping The new angular damping.
	 */
	public function setAngularDamping(damping: Float): Void;

	/**
	 * Sets the angular velocity of a Body.
	 * The angular velocity is the ''rate of change of angle over time''.
	 * This function will not accumulate anything; any impulses previously applied since the last call to World:update will be lost. 
	 * @param w The new angular velocity, in radians per second
	 */
	public function setAngularVelocity(w: Float): Void;

	/**
	 * Wakes the body up or puts it to sleep.
	 * @param awake The body sleep status.
	 */
	public function setAwake(awake: Bool): Void;

	/**
	 * Set the bullet status of a body.
	 * There are two methods to check for body collisions:
	 * *  at their location when the world is updated (default)
	 * *  using continuous collision detection (CCD)
	 * The default method is efficient, but a body moving very quickly may sometimes jump over another body without producing a collision. A body that is set as a bullet will use CCD. This is less efficient, but is guaranteed not to jump when moving quickly.
	 * Note that static bodies (with zero mass) always use CCD, so your walls will not let a fast moving body pass through even if it is not a bullet.
	 * @param status The bullet status of the body.
	 */
	public function setBullet(status: Bool): Void;

	/**
	 * Set whether a body has fixed rotation.
	 * Bodies with fixed rotation don't vary the speed at which they rotate. Calling this function causes the mass to be reset. 
	 * @param isFixed Whether the body should have fixed rotation.
	 */
	public function setFixedRotation(isFixed: Bool): Void;

	/**
	 * Sets a new gravity scale factor for the body.
	 * @param scale The new gravity scale factor.
	 */
	public function setGravityScale(scale: Float): Void;

	/**
	 * Set the inertia of a body.
	 * @param inertia The new moment of inertia, in kilograms * pixel squared.
	 */
	public function setInertia(inertia: Float): Void;

	/**
	 * Sets the linear damping of a Body
	 * See Body:getLinearDamping for a definition of linear damping.
	 * Linear damping can take any value from 0 to infinity. It is recommended to stay between 0 and 0.1, though. Other values will make the objects look 'floaty'(if gravity is enabled).
	 * @param ld The new linear damping
	 */
	public function setLinearDamping(ld: Float): Void;

	/**
	 * Sets a new linear velocity for the Body.
	 * This function will not accumulate anything; any impulses previously applied since the last call to World:update will be lost.
	 * @param x The x-component of the velocity vector.
	 * @param y The y-component of the velocity vector.
	 */
	public function setLinearVelocity(x: Float, y: Float): Void;

	/**
	 * Sets a new body mass.
	 * @param mass The mass, in kilograms.
	 */
	public function setMass(mass: Float): Void;

	/**
	 * Overrides the calculated mass data.
	 * @param x The x position of the center of mass.
	 * @param y The y position of the center of mass.
	 * @param mass The mass of the body.
	 * @param inertia The rotational inertia.
	 */
	public function setMassData(x: Float, y: Float, mass: Float, inertia: Float): Void;

	/**
	 * Set the position of the body.
	 * Note that this may not be the center of mass of the body.
	 * This function cannot wake up the body.
	 * @param x The x position.
	 * @param y The y position.
	 */
	public function setPosition(x: Float, y: Float): Void;

	/**
	 * Sets the sleeping behaviour of the body. Should sleeping be allowed, a body at rest will automatically sleep. A sleeping body is not simulated unless it collided with an awake body. Be wary that one can end up with a situation like a floating sleeping body if the floor was removed.
	 * @param allowed True if the body is allowed to sleep or false if not.
	 */
	public function setSleepingAllowed(allowed: Bool): Void;

	/**
	 * Set the position and angle of the body.
	 * Note that the position may not be the center of mass of the body. An angle of 0 radians will mean 'looking to the right'. Although radians increase counter-clockwise, the y axis points down so it becomes clockwise from our point of view.
	 * This function cannot wake up the body.
	 * @param x The x component of the position.
	 * @param y The y component of the position.
	 * @param angle The angle in radians.
	 */
	public function setTransform(x: Float, y: Float, angle: Float): Void;

	/**
	 * Sets a new body type.
	 * @param type The new type.
	 */
	public function setType(type: BodyType): Void;

	/**
	 * Associates a Lua value with the Body.
	 * To delete the reference, explicitly pass nil.
	 * @param value The Lua value to associate with the Body.
	 */
	public function setUserData(value: Dynamic): Void;

	/**
	 * Set the x position of the body.
	 * This function cannot wake up the body. 
	 * @param x The x position.
	 */
	public function setX(x: Float): Void;

	/**
	 * Set the y position of the body.
	 * This function cannot wake up the body. 
	 * @param y The y position.
	 */
	public function setY(y: Float): Void;
}