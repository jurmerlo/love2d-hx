// Generated by https://github.com/jurmerlo/love2d-hx.
// Love2D Version 11.5.

package love.physics;
import haxe.extern.Rest;
import lua.Table;
import lua.UserData;

/**
 * Shapes are solid 2d geometrical objects which handle the mass and collision of a Body in love.physics.
 * Shapes are attached to a Body via a Fixture. The Shape object is copied when this happens. 
 * The Shape's position is relative to the position of the Body it has been attached to.
 */
extern class Shape extends Object {

	/**
	 * Returns the points of the bounding box for the transformed shape.
	 * @param tx The translation of the shape on the x-axis.
	 * @param ty The translation of the shape on the y-axis.
	 * @param tr The shape rotation.
	 * @param childIndex The index of the child to compute the bounding box of.
	 */
	public function computeAABB(tx: Float, ty: Float, tr: Float, ?childIndex: Float): ShapeComputeAABBResult;

	/**
	 * Computes the mass properties for the shape with the specified density.
	 * @param density The shape density.
	 */
	public function computeMass(density: Float): ShapeComputeMassResult;

	/**
	 * Returns the number of children the shape has.
	 * @return The number of children.
	 */
	public function getChildCount(): Float;

	/**
	 * Gets the radius of the shape.
	 * @return The radius of the shape.
	 */
	public function getRadius(): Float;

	/**
	 * Gets a string representing the Shape.
	 * This function can be useful for conditional debug drawing.
	 * @return The type of the Shape.
	 */
	public function getType(): ShapeType;

	/**
	 * Casts a ray against the shape and returns the surface normal vector and the line position where the ray hit. If the ray missed the shape, nil will be returned. The Shape can be transformed to get it into the desired position.
	 * The ray starts on the first point of the input line and goes towards the second point of the line. The fourth argument is the maximum distance the ray is going to travel as a scale factor of the input line length.
	 * The childIndex parameter is used to specify which child of a parent shape, such as a ChainShape, will be ray casted. For ChainShapes, the index of 1 is the first edge on the chain. Ray casting a parent shape will only test the child specified so if you want to test every shape of the parent, you must loop through all of its children.
	 * The world position of the impact can be calculated by multiplying the line vector with the third return value and adding it to the line starting point.
	 * hitx, hity = x1 + (x2 - x1) * fraction, y1 + (y2 - y1) * fraction
	 * @param x1 The x position of the input line starting point.
	 * @param y1 The y position of the input line starting point.
	 * @param x2 The x position of the input line end point.
	 * @param y2 The y position of the input line end point.
	 * @param maxFraction Ray length parameter.
	 * @param tx The translation of the shape on the x-axis.
	 * @param ty The translation of the shape on the y-axis.
	 * @param tr The shape rotation.
	 * @param childIndex The index of the child the ray gets cast against.
	 */
	public function rayCast(x1: Float, y1: Float, x2: Float, y2: Float, maxFraction: Float, tx: Float, ty: Float, tr: Float, ?childIndex: Float): ShapeRayCastResult;

	/**
	 * This is particularly useful for mouse interaction with the shapes. By looping through all shapes and testing the mouse position with this function, we can find which shapes the mouse touches.
	 * @param tx Translates the shape along the x-axis.
	 * @param ty Translates the shape along the y-axis.
	 * @param tr Rotates the shape.
	 * @param x The x-component of the point.
	 * @param y The y-component of the point.
	 * @return True if inside, false if outside
	 */
	public function testPoint(tx: Float, ty: Float, tr: Float, x: Float, y: Float): Bool;
}

@:multiReturn
extern class ShapeRayCastResult {
	var xn: Float;
	var yn: Float;
	var fraction: Float;
}

@:multiReturn
extern class ShapeComputeMassResult {
	var x: Float;
	var y: Float;
	var mass: Float;
	var inertia: Float;
}

@:multiReturn
extern class ShapeComputeAABBResult {
	var topLeftX: Float;
	var topLeftY: Float;
	var bottomRightX: Float;
	var bottomRightY: Float;
}